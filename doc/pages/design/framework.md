\page framework 框架设计
\tableofcontents

## 痛点解析

在使用传统的电控嵌入式框架时，我们很容易遇到这样的问题：

+ 换块开发板，就要重新移植一遍所有的代码
+ 队伍中同时存在多套不一样的框架，维护成本爆炸
+ 要加减硬件需要手动注释或加入代码，导致很多抽象问题
+ 调试困难，裸机串口容易抽风，RTT又需要JLink
+ FreeRTOS乃至定时器难以满足越来越多的模块间通信需求
+ 代码改后压根不知道会不会对其它部分造成影响，导致抽象问题

通过在OneFramework中集成Zephyr框架，我们不仅能解决上述痛点，还可以进一步发展嵌入式框架，促进各种新功能、新技术的诞生。

## 核心概念

1. 硬件外设（Peripheral）

与MCU引脚直连的物理设备单元，包含传感器、执行器等基础硬件组件。

2. 设备树（DTS, Devicetree Source）  
   硬件描述语言文件，以声明式语法定义芯片外设配置、引脚映射及硬件特性参数。
3. Zephyr内核  
   基于微控制器的实时操作系统（RTOS），提供任务调度、内存管理等核心功能，类比Linux内核的嵌入式实现。
4. Kconfig配置系统  
   模块化配置管理机制，通过menuconfig/guiconfig图形界面或prj.conf配置文件实现功能的动态裁剪，支持条件编译与依赖管理。
5. 设备驱动（Driver）  
   基于DTS生成的硬件抽象层，提供标准化的设备操作API（如read/write），实现硬件资源的统一访问接口。

## 框架架构设计图

<center>
\image html Framework.png width=600px
</center>

## 方案比较

| 执行操作          | 传统框架                                               | OneFramework                                                             | 省下时间    |
|---------------|----------------------------------------------------|--------------------------------------------------------------------------|---------|
| 启用或禁用某硬件/模块   | 手动查找模块代码→注释代码→编译调试                                 | 使用guiconfig直接开启/关闭                                                       | 1分钟→10秒 |
| 调试代码          | 使用JLink RTT Viewer，但是会占用JLink通道，无法同时与Ozone使用       | 使用zephyr logger，可从任意自定义串口输出，不占用调试口；自带模块文件、内核时间信息；无实机环境下可使用qemu soc虚拟运行代码 | 5分钟→1分钟 |
| 配置模块间通信       | 需使用自研内存通信系统，实现收发模型，不一定能控制系统开销                      | 使用zephyr的zbus：开箱即用的线程间通信                                                 |         |
| 配置多任务执行       | 使用FreeRTOS等解决方案，依靠STM32CubeMX等定义任务相关参数，移植时可能遇到阻碍   | 使用zephyr的k_thread，用普通操作系统的线程模型直接开发（还可兼容POSIX线程）                          |         |
| 换硬件外设/开发板     | 新建仓库→手动配置调整硬件参数→复制粘贴各模块代码→手动上机调试→反复修改验证            | 新建外设/开发板DTS文件，编译通过后可直接上机调试。                                              | 1天→1小时  |
| 为不同兵种/新机器移植框架 | 新建仓库→可能还要使用代码生成器重新配一遍硬件→选择性复制粘贴模块→在任务调度器中配置模块→上机调试 | 新建app文件夹→使用guiconfig图形化配置启用各模块→上机调试                                      | 2天→1小时  |
| 扩展功能          | 各种开源框架均需手动移植或依赖CubeMX进行配置，多项目切换需要重新配置各种参数          | 享受Zephyr的丰富生态，包括LVGL、Network等开源驱动开箱即用                                    |         |
| 代码质量保障        | 看使用者心情                                             | 使用ZTest测试框架编写单元测试，在代码发生变动时通过Github Action自动发现失败测试，及时修正问题                 |         |

## 设计理念

### 软硬件解耦设计

#### 实现方案

+ 硬件描述与DTS绑定：通过设备树文件声明外设硬件参数（如GPIO引脚、SPI时钟频率等）
+ 驱动抽象层构建：利用Zephyr驱动框架自动生成device对象，建立硬件无关的标准化访问接口

#### 核心价值

+ 关注点分离  
  硬件工程师专注于电路设计与外设选型，软件开发者聚焦算法实现与驱动优化
+ 敏捷迭代能力  
  采用插件化架构设计，硬件变更仅需调整DTS配置，驱动层无需重构
+ 技术纵深拓展  
  支持硬件层（如定制开发板设计、高性能IMU集成）与软件层（新型控制算法、通信协议扩展）的独立演进，提升系统上限

### 测试驱动开发（TDD）

#### 实践路径

+ 单元测试先行：基于功能需求编写测试用例
+ 最小化代码实现：仅满足当前测试用例需求
+ 持续重构优化：通过代码审查与静态分析保证代码质量

#### 验证体系

+ 本地仿真测试：通过qemu_cortexsoc虚拟平台执行硬件无关逻辑验证
+ 自动化测试流水线：集成west twister测试框架与GitHub Actions，实现提交级别的回归测试
+ 硬件测试：关键模块部署至目标开发板进行物理验证

#### 质量保障优势

+ 缺陷预防：测试用例覆盖边界条件与异常场景，降低运行时错误概率
+ 架构优化：测试优先原则倒逼模块化设计，提升代码可维护性
+ 持续集成：自动化测试流水线确保每次提交的可交付性，降低集成风险

### 插件式配置管理

#### 模块化设计策略

+ 功能组件封装为独立库（Library），内含Kconfig配置接口
+ 构建时动态装配：通过menuconfig图形界面选择功能模块，自动解析依赖关系
+ 配置版本化：关键配置项固化于board.defconf文件，确保硬件兼容性

#### 工程效益

+ 资源精细化管控：按需加载功能模块，优化内存与存储占用
+ 可维护性提升：显式依赖声明避免隐式耦合，降低技术债务积累

### C++编译期优化

#### 性能增强策略

+ 元编程技术：应用constexpr计算、模板特化等C++20特性，将运行时决策提前至编译期
+ 零成本抽象：通过内联展开和死代码消除，消除算法库中的控制分支

#### 典型应用场景

+ 电机控制：PID算法循环中消除浮点运算条件判断
+ 传感器融合：卡尔曼滤波器的矩阵运算模板化优化

